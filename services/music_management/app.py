# Generated by Grok, created by xAI, Version: Grok (Fast setting), Date: 2025-10-06

from fastapi import FastAPI, HTTPException
from fastapi.responses import FileResponse
import requests
import yaml
import os
from models import Song, Session
from urllib.parse import urlparse
import subprocess  # For download

app = FastAPI(title="Music Management Service")

# Load config
with open('config.yaml', 'r') as f:
    config = yaml.safe_load(f)
jamendo = config['providers']['jamendo']

def search_jamendo(genre: str, limit: int = 10):
    url = f"{jamendo['base_url']}/tracks/"
    params = {
        'client_id': jamendo['client_id'],
        'format': 'jsonpretty',
        'limit': limit,
        'fuzzytags': f"genre:{genre}",  # Search by genre tag
        'include': 'musicinfo',
        'audiodownload': 'allowed'  # Filter downloadable
    }
    response = requests.get(url, params=params)
    if response.status_code != 200:
        raise HTTPException(status_code=500, detail="Jamendo API error")
    data = response.json()
    return data['results']

def download_track(track_id: int, download_url: str, local_path: str):
    if os.path.exists(local_path):
        return local_path
    # Download with requests
    resp = requests.get(download_url)
    if resp.status_code == 200:
        with open(local_path, 'wb') as f:
            f.write(resp.content)
        return local_path
    raise HTTPException(status_code=500, detail="Download failed")

@app.get("/search/{genre}")
def search_songs(genre: str, limit: int = 10):
    # Search Jamendo
    tracks = search_jamendo(genre, limit)
    songs = []
    session = Session()
    for track in tracks:
        # Check if already in DB
        existing = session.query(Song).filter_by(download_url=track['audiodownload']).first()
        if not existing:
            local_path = os.path.join(config['music_dir'], f"{track['id']}.mp3")
            try:
                download_path = download_track(track['id'], track['audiodownload'], local_path)
                credits = f"{track['artist_name']} - {track['name']} ({track['album_name']}) Licensed under {track['license_ccurl']}"
                song = Song(
                    title=track['name'],
                    artist=track['artist_name'],
                    genre=genre,
                    duration=track['duration'],
                    local_path=download_path,
                    download_url=track['audiodownload'],
                    license_ccurl=track['license_ccurl'],
                    credits=credits,
                    audiodownload_allowed=True
                )
                session.add(song)
                session.commit()
            except Exception as e:
                continue
        else:
            song = existing
        songs.append({
            'id': song.id,
            'title': song.title,
            'artist': song.artist,
            'genre': song.genre,
            'duration': song.duration,
            'credits': song.credits
        })
    session.close()
    return {'songs': songs}

@app.get("/song/{song_id}/credits")
def get_credits(song_id: int):
    session = Session()
    song = session.query(Song).get(song_id)
    session.close()
    if not song:
        raise HTTPException(status_code=404, detail="Song not found")
    return {'credits': song.credits}

@app.get("/song/{song_id}/file")
def get_song_file(song_id: int):
    session = Session()
    song = session.query(Song).get(song_id)
    session.close()
    if not song or not os.path.exists(song.local_path):
        raise HTTPException(status_code=404, detail="File not found")
    return FileResponse(song.local_path, media_type='audio/mpeg')

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8007)